# Python

### Generator
- yield 구문을 사용하여 데이터를 원하는 시점에 반환하고 처리를 다시 시작할 수 있는 함수
- 일반적인 함수는 진입점이 하나지만 제너레이터는 진입점이 여러개
- 실행 중간에 일시정지할 수 있는 Coroutine 함수의 구현체
- 또한 외부에서 send\(\)를 통해 데이터를 받을 수도 있음
- 장점
    - iterable한 객체는 보통 모든 값을 메모리에 담고 있어야 해서 메모리 낭비 발생
    - generator는 필요한 값만 생성하기 때문에 모든 값을 가지고 있을 필요가 없음
- 단점
    - 한번 사용된 후에는 다시 사용할 수 없음

### 클래스 상속 시 메소드 실행 방식
- C3 알고리즘에 따른 \_\_mro\_\_ \(Method Resolution Order\)를 통해 메소드를 가져옴
    - MRO: 다중 상속 시 왼쪽에 있을 수록, 자식일수록 우선순위가 높음
- 다이아몬드 상속 시에 메소드를 가져오는 순서를 정해두어 이로 인해 발생하는 문제 해결

### GIL \(Global Interpreter Lock\)
- GIL은 인터프리터에서 동작하는 여러 개의 쓰레드 중 오직 하나만 실행되도록 Lock을 걸음
    - 따라서 멀티 쓰레드 환경에서도 결국 싱글 쓰레드로 동작
- 사용 이유
    - Python의 Garbage Collection 방식인 Reference Counting 시 공유 자원인 REFCNT에 대한 동시 접근 방지를 위해
- 장점
    - 보통의 멀티쓰레드보다 구현이 간단하고 싱글 쓰레드 성능이 우수
    - CPU-bound 작업은 싱글쓰레드 성능이지만, IO-bound 작업은 성능이 우수함
        - IO작업을 기다리는 중에 다른 쓰레드가 실행되므로
- 대안
    - 멀티프로세싱
    - asyncio: 비동기 프로그래밍

### Garbage Collection
- 기본적으로 Reference Counting을 통해 메모리 관리
    - 메모리 할당 시 해당 메모리를 참조하는 객체의 수를 카운팅, 0이 되면 메모리 해제
- Reference Counting의 문제점인 순환 참조\(reference cycle\) 발생 시 GC로 해결
    - 순환참조란 서로가 서로를 가리키거나, 자신이 자신을 가리키는 상황 등으로 인해 카운트가 0이 되지 않는 것
- Python GC는 세대별 GC로 동작
    - Generational Hypothesis
        - 새롭게 만들어진 대부분의 객체는 금방 사라지거나 도달할 수 없는 상태가 됨
        - 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재
    - 보통 3개의 세대와 각각의 임계값\(threshold\) 존재
    - 할당된 객체의 수가 임계값을 초과하면 GC 수행, 살아남으면 다음 세대로 보냄
- 순환참조는 컨테이너 객체\(list, tuple 등\)에서만 발생하므로 이를 모두 추적 관리
- 순환참조 탐지 방법
    1. 객체에 refs필드를 레퍼런스 카운트로 설정
    2. 각 객체에서 참조하고 있는 다른 컨테이너 객체를 찾고, 참조되는 컨테이너의 refs 감소시킴
    3. refs가 0이면 그 객체는 컨테이너 집합 내부에서 자기들끼리 참조하고 있다는 의미
    4. 이를 unreachable하다고 표시한 뒤 메모리에서 해제

### PyPy가 CPython보다 빠른 이유
- CPython은 일반적인 인터프리터지만 PyPy는 실행 추적 JIT 컴파일을 제공하는 인터프리터이기 때문
    - 실행 추적 JIT: 메소드 단위로 최적화하는 보통의 JIT와는 다르게 런타임에서 자주 실행되는 루프를 최적화
- PyPy
    - 컴파일 가능한 Python인 RPython으로 인터프리터 작성
    - C로 구현한 실행 추적 JIT 컴파일러를 인터프리터에 빌드
    - 이것으로 Python 소스 코드를 실행

### 메모리 누수 발생 경우
- `__del__()` 메소드 재작성 시
- 기본 인자값으로 mutable 객체를 사용 시
    - `def foo(a=[]):`
    - foo함수를 실행할 때마다 a에 작업 진행

### Duck Typing
- 객체의 실제 타입보다는 객체의 변수와 메소드가 그 객체의 적합성을 결정
    - 주로 동적 타입을 가지는 언어에서 많이 사용되는 개념
    - 런타임 시에 그 객체의 적합성을 결정할 수 있음
- 예시
    - `__iter__()`와 `__getitem__()`을 통해 iterable함을 표현
        - Java처럼 Iterable 인터페이스를 상속받거나 하지 않음
